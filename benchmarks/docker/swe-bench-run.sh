#!/usr/bin/env bash
# SWE-bench test runner entrypoint.
#
# Mounted at runtime inside the Docker container. Reads input files from
# /work/, executes the test commands, and writes result files back to /work/.
#
# Inputs (all in /work/):
#   base_commit  - git ref to reset to before applying patches
#   agent.patch  - the agent's code changes
#   test.patch   - the SWE-bench test patch
#   f2p_cmd      - shell command for FAIL_TO_PASS tests
#   p2p_cmd      - shell command for PASS_TO_PASS tests (may be empty)
#
# Outputs (all in /work/):
#   f2p_exit     - exit code of FAIL_TO_PASS test run
#   f2p_stdout   - stdout of FAIL_TO_PASS test run
#   f2p_stderr   - stderr of FAIL_TO_PASS test run
#   p2p_exit     - exit code of PASS_TO_PASS test run
#   p2p_stdout   - stdout of PASS_TO_PASS test run
#   p2p_stderr   - stderr of PASS_TO_PASS test run
#   error        - non-empty if something went wrong before tests could run

set -u

WORK=/work
REPO=/repo

# Read inputs
BASE_COMMIT=$(cat "$WORK/base_commit" 2>/dev/null)
F2P_CMD=$(cat "$WORK/f2p_cmd" 2>/dev/null)
P2P_CMD=$(cat "$WORK/p2p_cmd" 2>/dev/null)

# Reset repo to base commit.
# Use -fd (NOT -fdx): -x would nuke .gitignore'd files like _version.py
# that were generated by `pip install -e .` during the Docker build.
cd "$REPO" || { echo "cannot cd to $REPO" > "$WORK/error"; exit 0; }
git reset --hard "$BASE_COMMIT" 2>/dev/null
git clean -fd 2>/dev/null

# Apply agent patch
if [ -s "$WORK/agent.patch" ]; then
    git apply --verbose "$WORK/agent.patch" 2>/dev/null \
        || git apply --3way --verbose "$WORK/agent.patch" 2>/dev/null \
        || { echo "agent patch failed to apply" > "$WORK/error"; exit 0; }
fi

# Apply test patch
if [ -s "$WORK/test.patch" ]; then
    git apply --verbose "$WORK/test.patch" 2>/dev/null \
        || git apply --3way --verbose "$WORK/test.patch" 2>/dev/null \
        || { echo "test patch failed to apply" > "$WORK/error"; exit 0; }
fi

# Run FAIL_TO_PASS tests
if [ -n "$F2P_CMD" ]; then
    eval "$F2P_CMD" > "$WORK/f2p_stdout" 2> "$WORK/f2p_stderr"
    echo $? > "$WORK/f2p_exit"
else
    echo "no f2p_cmd provided" > "$WORK/error"
    exit 0
fi

# Run PASS_TO_PASS tests (optional)
if [ -n "$P2P_CMD" ]; then
    eval "$P2P_CMD" > "$WORK/p2p_stdout" 2> "$WORK/p2p_stderr"
    echo $? > "$WORK/p2p_exit"
else
    # No P2P tests, mark as passed
    echo "0" > "$WORK/p2p_exit"
    echo "" > "$WORK/p2p_stdout"
    echo "" > "$WORK/p2p_stderr"
fi
